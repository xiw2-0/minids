// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minidfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minidfs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minidfs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minidfs_2eproto;
namespace minidfs {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class ChunkserverInfo;
class ChunkserverInfoDefaultTypeInternal;
extern ChunkserverInfoDefaultTypeInternal _ChunkserverInfo_default_instance_;
class FileStorageInfo;
class FileStorageInfoDefaultTypeInternal;
extern FileStorageInfoDefaultTypeInternal _FileStorageInfo_default_instance_;
class LocatedBlock;
class LocatedBlockDefaultTypeInternal;
extern LocatedBlockDefaultTypeInternal _LocatedBlock_default_instance_;
class LocatedBlocks;
class LocatedBlocksDefaultTypeInternal;
extern LocatedBlocksDefaultTypeInternal _LocatedBlocks_default_instance_;
}  // namespace minidfs
PROTOBUF_NAMESPACE_OPEN
template<> ::minidfs::Block* Arena::CreateMaybeMessage<::minidfs::Block>(Arena*);
template<> ::minidfs::ChunkserverInfo* Arena::CreateMaybeMessage<::minidfs::ChunkserverInfo>(Arena*);
template<> ::minidfs::FileStorageInfo* Arena::CreateMaybeMessage<::minidfs::FileStorageInfo>(Arena*);
template<> ::minidfs::LocatedBlock* Arena::CreateMaybeMessage<::minidfs::LocatedBlock>(Arena*);
template<> ::minidfs::LocatedBlocks* Arena::CreateMaybeMessage<::minidfs::LocatedBlocks>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minidfs {

// ===================================================================

class Block :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.Block";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockLenFieldNumber = 2,
    kBlockIDFieldNumber = 1,
  };
  // int64 blockLen = 2;
  void clear_blocklen();
  ::PROTOBUF_NAMESPACE_ID::int64 blocklen() const;
  void set_blocklen(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 blockID = 1;
  void clear_blockid();
  ::PROTOBUF_NAMESPACE_ID::int32 blockid() const;
  void set_blockid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.Block)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 blocklen_;
  ::PROTOBUF_NAMESPACE_ID::int32 blockid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class ChunkserverInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.ChunkserverInfo) */ {
 public:
  ChunkserverInfo();
  virtual ~ChunkserverInfo();

  ChunkserverInfo(const ChunkserverInfo& from);
  ChunkserverInfo(ChunkserverInfo&& from) noexcept
    : ChunkserverInfo() {
    *this = ::std::move(from);
  }

  inline ChunkserverInfo& operator=(const ChunkserverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkserverInfo& operator=(ChunkserverInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChunkserverInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChunkserverInfo* internal_default_instance() {
    return reinterpret_cast<const ChunkserverInfo*>(
               &_ChunkserverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChunkserverInfo& a, ChunkserverInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkserverInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChunkserverInfo* New() const final {
    return CreateMaybeMessage<ChunkserverInfo>(nullptr);
  }

  ChunkserverInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChunkserverInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChunkserverInfo& from);
  void MergeFrom(const ChunkserverInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkserverInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.ChunkserverInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkserverIPFieldNumber = 1,
    kChunkserverPortFieldNumber = 2,
  };
  // string chunkserverIP = 1;
  void clear_chunkserverip();
  const std::string& chunkserverip() const;
  void set_chunkserverip(const std::string& value);
  void set_chunkserverip(std::string&& value);
  void set_chunkserverip(const char* value);
  void set_chunkserverip(const char* value, size_t size);
  std::string* mutable_chunkserverip();
  std::string* release_chunkserverip();
  void set_allocated_chunkserverip(std::string* chunkserverip);

  // int32 chunkserverPort = 2;
  void clear_chunkserverport();
  ::PROTOBUF_NAMESPACE_ID::int32 chunkserverport() const;
  void set_chunkserverport(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.ChunkserverInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunkserverip_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunkserverport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.LocatedBlock) */ {
 public:
  LocatedBlock();
  virtual ~LocatedBlock();

  LocatedBlock(const LocatedBlock& from);
  LocatedBlock(LocatedBlock&& from) noexcept
    : LocatedBlock() {
    *this = ::std::move(from);
  }

  inline LocatedBlock& operator=(const LocatedBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlock& operator=(LocatedBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlock* internal_default_instance() {
    return reinterpret_cast<const LocatedBlock*>(
               &_LocatedBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LocatedBlock& a, LocatedBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlock* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlock* New() const final {
    return CreateMaybeMessage<LocatedBlock>(nullptr);
  }

  LocatedBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlock& from);
  void MergeFrom(const LocatedBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.LocatedBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkserverInfosFieldNumber = 2,
    kBlockFieldNumber = 1,
  };
  // repeated .minidfs.ChunkserverInfo chunkserverInfos = 2;
  int chunkserverinfos_size() const;
  void clear_chunkserverinfos();
  ::minidfs::ChunkserverInfo* mutable_chunkserverinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >*
      mutable_chunkserverinfos();
  const ::minidfs::ChunkserverInfo& chunkserverinfos(int index) const;
  ::minidfs::ChunkserverInfo* add_chunkserverinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >&
      chunkserverinfos() const;

  // .minidfs.Block block = 1;
  bool has_block() const;
  void clear_block();
  const ::minidfs::Block& block() const;
  ::minidfs::Block* release_block();
  ::minidfs::Block* mutable_block();
  void set_allocated_block(::minidfs::Block* block);

  // @@protoc_insertion_point(class_scope:minidfs.LocatedBlock)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo > chunkserverinfos_;
  ::minidfs::Block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlocks :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.LocatedBlocks) */ {
 public:
  LocatedBlocks();
  virtual ~LocatedBlocks();

  LocatedBlocks(const LocatedBlocks& from);
  LocatedBlocks(LocatedBlocks&& from) noexcept
    : LocatedBlocks() {
    *this = ::std::move(from);
  }

  inline LocatedBlocks& operator=(const LocatedBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlocks& operator=(LocatedBlocks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlocks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlocks* internal_default_instance() {
    return reinterpret_cast<const LocatedBlocks*>(
               &_LocatedBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocatedBlocks& a, LocatedBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlocks* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlocks* New() const final {
    return CreateMaybeMessage<LocatedBlocks>(nullptr);
  }

  LocatedBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlocks>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlocks& from);
  void MergeFrom(const LocatedBlocks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlocks* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.LocatedBlocks";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocatedBlksFieldNumber = 1,
  };
  // repeated .minidfs.LocatedBlock locatedBlks = 1;
  int locatedblks_size() const;
  void clear_locatedblks();
  ::minidfs::LocatedBlock* mutable_locatedblks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
      mutable_locatedblks();
  const ::minidfs::LocatedBlock& locatedblks(int index) const;
  ::minidfs::LocatedBlock* add_locatedblks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
      locatedblks() const;

  // @@protoc_insertion_point(class_scope:minidfs.LocatedBlocks)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock > locatedblks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class FileStorageInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.FileStorageInfo) */ {
 public:
  FileStorageInfo();
  virtual ~FileStorageInfo();

  FileStorageInfo(const FileStorageInfo& from);
  FileStorageInfo(FileStorageInfo&& from) noexcept
    : FileStorageInfo() {
    *this = ::std::move(from);
  }

  inline FileStorageInfo& operator=(const FileStorageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileStorageInfo& operator=(FileStorageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileStorageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileStorageInfo* internal_default_instance() {
    return reinterpret_cast<const FileStorageInfo*>(
               &_FileStorageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileStorageInfo& a, FileStorageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileStorageInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileStorageInfo* New() const final {
    return CreateMaybeMessage<FileStorageInfo>(nullptr);
  }

  FileStorageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileStorageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileStorageInfo& from);
  void MergeFrom(const FileStorageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileStorageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.FileStorageInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocatedblksFieldNumber = 2,
    kFileFieldNumber = 1,
  };
  // repeated .minidfs.LocatedBlock locatedblks = 2;
  int locatedblks_size() const;
  void clear_locatedblks();
  ::minidfs::LocatedBlock* mutable_locatedblks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
      mutable_locatedblks();
  const ::minidfs::LocatedBlock& locatedblks(int index) const;
  ::minidfs::LocatedBlock* add_locatedblks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
      locatedblks() const;

  // string file = 1;
  void clear_file();
  const std::string& file() const;
  void set_file(const std::string& value);
  void set_file(std::string&& value);
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  std::string* mutable_file();
  std::string* release_file();
  void set_allocated_file(std::string* file);

  // @@protoc_insertion_point(class_scope:minidfs.FileStorageInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock > locatedblks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Block

// int32 blockID = 1;
inline void Block::clear_blockid() {
  blockid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Block::blockid() const {
  // @@protoc_insertion_point(field_get:minidfs.Block.blockID)
  return blockid_;
}
inline void Block::set_blockid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  blockid_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Block.blockID)
}

// int64 blockLen = 2;
inline void Block::clear_blocklen() {
  blocklen_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::blocklen() const {
  // @@protoc_insertion_point(field_get:minidfs.Block.blockLen)
  return blocklen_;
}
inline void Block::set_blocklen(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  blocklen_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Block.blockLen)
}

// -------------------------------------------------------------------

// ChunkserverInfo

// string chunkserverIP = 1;
inline void ChunkserverInfo::clear_chunkserverip() {
  chunkserverip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChunkserverInfo::chunkserverip() const {
  // @@protoc_insertion_point(field_get:minidfs.ChunkserverInfo.chunkserverIP)
  return chunkserverip_.GetNoArena();
}
inline void ChunkserverInfo::set_chunkserverip(const std::string& value) {
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(std::string&& value) {
  
  chunkserverip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(const char* value, size_t size) {
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.ChunkserverInfo.chunkserverIP)
}
inline std::string* ChunkserverInfo::mutable_chunkserverip() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.ChunkserverInfo.chunkserverIP)
  return chunkserverip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChunkserverInfo::release_chunkserverip() {
  // @@protoc_insertion_point(field_release:minidfs.ChunkserverInfo.chunkserverIP)
  
  return chunkserverip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChunkserverInfo::set_allocated_chunkserverip(std::string* chunkserverip) {
  if (chunkserverip != nullptr) {
    
  } else {
    
  }
  chunkserverip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunkserverip);
  // @@protoc_insertion_point(field_set_allocated:minidfs.ChunkserverInfo.chunkserverIP)
}

// int32 chunkserverPort = 2;
inline void ChunkserverInfo::clear_chunkserverport() {
  chunkserverport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkserverInfo::chunkserverport() const {
  // @@protoc_insertion_point(field_get:minidfs.ChunkserverInfo.chunkserverPort)
  return chunkserverport_;
}
inline void ChunkserverInfo::set_chunkserverport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chunkserverport_ = value;
  // @@protoc_insertion_point(field_set:minidfs.ChunkserverInfo.chunkserverPort)
}

// -------------------------------------------------------------------

// LocatedBlock

// .minidfs.Block block = 1;
inline bool LocatedBlock::has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline void LocatedBlock::clear_block() {
  if (GetArenaNoVirtual() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::minidfs::Block& LocatedBlock::block() const {
  const ::minidfs::Block* p = block_;
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlock.block)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::Block*>(
      &::minidfs::_Block_default_instance_);
}
inline ::minidfs::Block* LocatedBlock::release_block() {
  // @@protoc_insertion_point(field_release:minidfs.LocatedBlock.block)
  
  ::minidfs::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::minidfs::Block* LocatedBlock::mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlock.block)
  return block_;
}
inline void LocatedBlock::set_allocated_block(::minidfs::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:minidfs.LocatedBlock.block)
}

// repeated .minidfs.ChunkserverInfo chunkserverInfos = 2;
inline int LocatedBlock::chunkserverinfos_size() const {
  return chunkserverinfos_.size();
}
inline void LocatedBlock::clear_chunkserverinfos() {
  chunkserverinfos_.Clear();
}
inline ::minidfs::ChunkserverInfo* LocatedBlock::mutable_chunkserverinfos(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >*
LocatedBlock::mutable_chunkserverinfos() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.LocatedBlock.chunkserverInfos)
  return &chunkserverinfos_;
}
inline const ::minidfs::ChunkserverInfo& LocatedBlock::chunkserverinfos(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Get(index);
}
inline ::minidfs::ChunkserverInfo* LocatedBlock::add_chunkserverinfos() {
  // @@protoc_insertion_point(field_add:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >&
LocatedBlock::chunkserverinfos() const {
  // @@protoc_insertion_point(field_list:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_;
}

// -------------------------------------------------------------------

// LocatedBlocks

// repeated .minidfs.LocatedBlock locatedBlks = 1;
inline int LocatedBlocks::locatedblks_size() const {
  return locatedblks_.size();
}
inline void LocatedBlocks::clear_locatedblks() {
  locatedblks_.Clear();
}
inline ::minidfs::LocatedBlock* LocatedBlocks::mutable_locatedblks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
LocatedBlocks::mutable_locatedblks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.LocatedBlocks.locatedBlks)
  return &locatedblks_;
}
inline const ::minidfs::LocatedBlock& LocatedBlocks::locatedblks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Get(index);
}
inline ::minidfs::LocatedBlock* LocatedBlocks::add_locatedblks() {
  // @@protoc_insertion_point(field_add:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
LocatedBlocks::locatedblks() const {
  // @@protoc_insertion_point(field_list:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_;
}

// -------------------------------------------------------------------

// FileStorageInfo

// string file = 1;
inline void FileStorageInfo::clear_file() {
  file_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FileStorageInfo::file() const {
  // @@protoc_insertion_point(field_get:minidfs.FileStorageInfo.file)
  return file_.GetNoArena();
}
inline void FileStorageInfo::set_file(const std::string& value) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.FileStorageInfo.file)
}
inline void FileStorageInfo::set_file(std::string&& value) {
  
  file_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.FileStorageInfo.file)
}
inline void FileStorageInfo::set_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.FileStorageInfo.file)
}
inline void FileStorageInfo::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.FileStorageInfo.file)
}
inline std::string* FileStorageInfo::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.FileStorageInfo.file)
  return file_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileStorageInfo::release_file() {
  // @@protoc_insertion_point(field_release:minidfs.FileStorageInfo.file)
  
  return file_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileStorageInfo::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:minidfs.FileStorageInfo.file)
}

// repeated .minidfs.LocatedBlock locatedblks = 2;
inline int FileStorageInfo::locatedblks_size() const {
  return locatedblks_.size();
}
inline void FileStorageInfo::clear_locatedblks() {
  locatedblks_.Clear();
}
inline ::minidfs::LocatedBlock* FileStorageInfo::mutable_locatedblks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.FileStorageInfo.locatedblks)
  return locatedblks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
FileStorageInfo::mutable_locatedblks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.FileStorageInfo.locatedblks)
  return &locatedblks_;
}
inline const ::minidfs::LocatedBlock& FileStorageInfo::locatedblks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.FileStorageInfo.locatedblks)
  return locatedblks_.Get(index);
}
inline ::minidfs::LocatedBlock* FileStorageInfo::add_locatedblks() {
  // @@protoc_insertion_point(field_add:minidfs.FileStorageInfo.locatedblks)
  return locatedblks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
FileStorageInfo::locatedblks() const {
  // @@protoc_insertion_point(field_list:minidfs.FileStorageInfo.locatedblks)
  return locatedblks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace minidfs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto
