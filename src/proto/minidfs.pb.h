// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minidfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minidfs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minidfs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minidfs_2eproto;
namespace minidfs {
class BlkIDs;
class BlkIDsDefaultTypeInternal;
extern BlkIDsDefaultTypeInternal _BlkIDs_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockReport;
class BlockReportDefaultTypeInternal;
extern BlockReportDefaultTypeInternal _BlockReport_default_instance_;
class BlockTask;
class BlockTaskDefaultTypeInternal;
extern BlockTaskDefaultTypeInternal _BlockTask_default_instance_;
class BlockTasks;
class BlockTasksDefaultTypeInternal;
extern BlockTasksDefaultTypeInternal _BlockTasks_default_instance_;
class ChunkserverInfo;
class ChunkserverInfoDefaultTypeInternal;
extern ChunkserverInfoDefaultTypeInternal _ChunkserverInfo_default_instance_;
class Dentry;
class DentryDefaultTypeInternal;
extern DentryDefaultTypeInternal _Dentry_default_instance_;
class DentrySection;
class DentrySectionDefaultTypeInternal;
extern DentrySectionDefaultTypeInternal _DentrySection_default_instance_;
class EditLog;
class EditLogDefaultTypeInternal;
extern EditLogDefaultTypeInternal _EditLog_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FileInfos;
class FileInfosDefaultTypeInternal;
extern FileInfosDefaultTypeInternal _FileInfos_default_instance_;
class Inode;
class InodeDefaultTypeInternal;
extern InodeDefaultTypeInternal _Inode_default_instance_;
class InodeSection;
class InodeSectionDefaultTypeInternal;
extern InodeSectionDefaultTypeInternal _InodeSection_default_instance_;
class LocatedBlock;
class LocatedBlockDefaultTypeInternal;
extern LocatedBlockDefaultTypeInternal _LocatedBlock_default_instance_;
class LocatedBlocks;
class LocatedBlocksDefaultTypeInternal;
extern LocatedBlocksDefaultTypeInternal _LocatedBlocks_default_instance_;
class NameSystem;
class NameSystemDefaultTypeInternal;
extern NameSystemDefaultTypeInternal _NameSystem_default_instance_;
}  // namespace minidfs
PROTOBUF_NAMESPACE_OPEN
template<> ::minidfs::BlkIDs* Arena::CreateMaybeMessage<::minidfs::BlkIDs>(Arena*);
template<> ::minidfs::Block* Arena::CreateMaybeMessage<::minidfs::Block>(Arena*);
template<> ::minidfs::BlockReport* Arena::CreateMaybeMessage<::minidfs::BlockReport>(Arena*);
template<> ::minidfs::BlockTask* Arena::CreateMaybeMessage<::minidfs::BlockTask>(Arena*);
template<> ::minidfs::BlockTasks* Arena::CreateMaybeMessage<::minidfs::BlockTasks>(Arena*);
template<> ::minidfs::ChunkserverInfo* Arena::CreateMaybeMessage<::minidfs::ChunkserverInfo>(Arena*);
template<> ::minidfs::Dentry* Arena::CreateMaybeMessage<::minidfs::Dentry>(Arena*);
template<> ::minidfs::DentrySection* Arena::CreateMaybeMessage<::minidfs::DentrySection>(Arena*);
template<> ::minidfs::EditLog* Arena::CreateMaybeMessage<::minidfs::EditLog>(Arena*);
template<> ::minidfs::FileInfo* Arena::CreateMaybeMessage<::minidfs::FileInfo>(Arena*);
template<> ::minidfs::FileInfos* Arena::CreateMaybeMessage<::minidfs::FileInfos>(Arena*);
template<> ::minidfs::Inode* Arena::CreateMaybeMessage<::minidfs::Inode>(Arena*);
template<> ::minidfs::InodeSection* Arena::CreateMaybeMessage<::minidfs::InodeSection>(Arena*);
template<> ::minidfs::LocatedBlock* Arena::CreateMaybeMessage<::minidfs::LocatedBlock>(Arena*);
template<> ::minidfs::LocatedBlocks* Arena::CreateMaybeMessage<::minidfs::LocatedBlocks>(Arena*);
template<> ::minidfs::NameSystem* Arena::CreateMaybeMessage<::minidfs::NameSystem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minidfs {

// ===================================================================

class Block :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.Block";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockLenFieldNumber = 2,
    kBlockIDFieldNumber = 1,
  };
  // int64 blockLen = 2;
  void clear_blocklen();
  ::PROTOBUF_NAMESPACE_ID::int64 blocklen() const;
  void set_blocklen(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 blockID = 1;
  void clear_blockid();
  ::PROTOBUF_NAMESPACE_ID::int32 blockid() const;
  void set_blockid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.Block)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 blocklen_;
  ::PROTOBUF_NAMESPACE_ID::int32 blockid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class ChunkserverInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.ChunkserverInfo) */ {
 public:
  ChunkserverInfo();
  virtual ~ChunkserverInfo();

  ChunkserverInfo(const ChunkserverInfo& from);
  ChunkserverInfo(ChunkserverInfo&& from) noexcept
    : ChunkserverInfo() {
    *this = ::std::move(from);
  }

  inline ChunkserverInfo& operator=(const ChunkserverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkserverInfo& operator=(ChunkserverInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChunkserverInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChunkserverInfo* internal_default_instance() {
    return reinterpret_cast<const ChunkserverInfo*>(
               &_ChunkserverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChunkserverInfo& a, ChunkserverInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkserverInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChunkserverInfo* New() const final {
    return CreateMaybeMessage<ChunkserverInfo>(nullptr);
  }

  ChunkserverInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChunkserverInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChunkserverInfo& from);
  void MergeFrom(const ChunkserverInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkserverInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.ChunkserverInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkserverIPFieldNumber = 1,
    kChunkserverPortFieldNumber = 2,
  };
  // string chunkserverIP = 1;
  void clear_chunkserverip();
  const std::string& chunkserverip() const;
  void set_chunkserverip(const std::string& value);
  void set_chunkserverip(std::string&& value);
  void set_chunkserverip(const char* value);
  void set_chunkserverip(const char* value, size_t size);
  std::string* mutable_chunkserverip();
  std::string* release_chunkserverip();
  void set_allocated_chunkserverip(std::string* chunkserverip);

  // int32 chunkserverPort = 2;
  void clear_chunkserverport();
  ::PROTOBUF_NAMESPACE_ID::int32 chunkserverport() const;
  void set_chunkserverport(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.ChunkserverInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunkserverip_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunkserverport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.LocatedBlock) */ {
 public:
  LocatedBlock();
  virtual ~LocatedBlock();

  LocatedBlock(const LocatedBlock& from);
  LocatedBlock(LocatedBlock&& from) noexcept
    : LocatedBlock() {
    *this = ::std::move(from);
  }

  inline LocatedBlock& operator=(const LocatedBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlock& operator=(LocatedBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlock* internal_default_instance() {
    return reinterpret_cast<const LocatedBlock*>(
               &_LocatedBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LocatedBlock& a, LocatedBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlock* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlock* New() const final {
    return CreateMaybeMessage<LocatedBlock>(nullptr);
  }

  LocatedBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlock& from);
  void MergeFrom(const LocatedBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.LocatedBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkserverInfosFieldNumber = 2,
    kBlockFieldNumber = 1,
  };
  // repeated .minidfs.ChunkserverInfo chunkserverInfos = 2;
  int chunkserverinfos_size() const;
  void clear_chunkserverinfos();
  ::minidfs::ChunkserverInfo* mutable_chunkserverinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >*
      mutable_chunkserverinfos();
  const ::minidfs::ChunkserverInfo& chunkserverinfos(int index) const;
  ::minidfs::ChunkserverInfo* add_chunkserverinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >&
      chunkserverinfos() const;

  // .minidfs.Block block = 1;
  bool has_block() const;
  void clear_block();
  const ::minidfs::Block& block() const;
  ::minidfs::Block* release_block();
  ::minidfs::Block* mutable_block();
  void set_allocated_block(::minidfs::Block* block);

  // @@protoc_insertion_point(class_scope:minidfs.LocatedBlock)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo > chunkserverinfos_;
  ::minidfs::Block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlocks :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.LocatedBlocks) */ {
 public:
  LocatedBlocks();
  virtual ~LocatedBlocks();

  LocatedBlocks(const LocatedBlocks& from);
  LocatedBlocks(LocatedBlocks&& from) noexcept
    : LocatedBlocks() {
    *this = ::std::move(from);
  }

  inline LocatedBlocks& operator=(const LocatedBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlocks& operator=(LocatedBlocks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlocks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlocks* internal_default_instance() {
    return reinterpret_cast<const LocatedBlocks*>(
               &_LocatedBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocatedBlocks& a, LocatedBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlocks* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlocks* New() const final {
    return CreateMaybeMessage<LocatedBlocks>(nullptr);
  }

  LocatedBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlocks>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlocks& from);
  void MergeFrom(const LocatedBlocks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlocks* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.LocatedBlocks";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocatedBlksFieldNumber = 1,
  };
  // repeated .minidfs.LocatedBlock locatedBlks = 1;
  int locatedblks_size() const;
  void clear_locatedblks();
  ::minidfs::LocatedBlock* mutable_locatedblks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
      mutable_locatedblks();
  const ::minidfs::LocatedBlock& locatedblks(int index) const;
  ::minidfs::LocatedBlock* add_locatedblks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
      locatedblks() const;

  // @@protoc_insertion_point(class_scope:minidfs.LocatedBlocks)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock > locatedblks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class BlkIDs :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.BlkIDs) */ {
 public:
  BlkIDs();
  virtual ~BlkIDs();

  BlkIDs(const BlkIDs& from);
  BlkIDs(BlkIDs&& from) noexcept
    : BlkIDs() {
    *this = ::std::move(from);
  }

  inline BlkIDs& operator=(const BlkIDs& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlkIDs& operator=(BlkIDs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlkIDs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlkIDs* internal_default_instance() {
    return reinterpret_cast<const BlkIDs*>(
               &_BlkIDs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlkIDs& a, BlkIDs& b) {
    a.Swap(&b);
  }
  inline void Swap(BlkIDs* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlkIDs* New() const final {
    return CreateMaybeMessage<BlkIDs>(nullptr);
  }

  BlkIDs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlkIDs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlkIDs& from);
  void MergeFrom(const BlkIDs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlkIDs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.BlkIDs";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlkIDsFieldNumber = 1,
  };
  // repeated int32 blkIDs = 1;
  int blkids_size() const;
  void clear_blkids();
  ::PROTOBUF_NAMESPACE_ID::int32 blkids(int index) const;
  void set_blkids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_blkids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      blkids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_blkids();

  // @@protoc_insertion_point(class_scope:minidfs.BlkIDs)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > blkids_;
  mutable std::atomic<int> _blkids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class BlockReport :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.BlockReport) */ {
 public:
  BlockReport();
  virtual ~BlockReport();

  BlockReport(const BlockReport& from);
  BlockReport(BlockReport&& from) noexcept
    : BlockReport() {
    *this = ::std::move(from);
  }

  inline BlockReport& operator=(const BlockReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockReport& operator=(BlockReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockReport* internal_default_instance() {
    return reinterpret_cast<const BlockReport*>(
               &_BlockReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockReport& a, BlockReport& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockReport* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockReport* New() const final {
    return CreateMaybeMessage<BlockReport>(nullptr);
  }

  BlockReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockReport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockReport& from);
  void MergeFrom(const BlockReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockReport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.BlockReport";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlkIDsFieldNumber = 2,
    kChunkserverInfoFieldNumber = 1,
  };
  // repeated int32 blkIDs = 2;
  int blkids_size() const;
  void clear_blkids();
  ::PROTOBUF_NAMESPACE_ID::int32 blkids(int index) const;
  void set_blkids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_blkids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      blkids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_blkids();

  // .minidfs.ChunkserverInfo chunkserverInfo = 1;
  bool has_chunkserverinfo() const;
  void clear_chunkserverinfo();
  const ::minidfs::ChunkserverInfo& chunkserverinfo() const;
  ::minidfs::ChunkserverInfo* release_chunkserverinfo();
  ::minidfs::ChunkserverInfo* mutable_chunkserverinfo();
  void set_allocated_chunkserverinfo(::minidfs::ChunkserverInfo* chunkserverinfo);

  // @@protoc_insertion_point(class_scope:minidfs.BlockReport)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > blkids_;
  mutable std::atomic<int> _blkids_cached_byte_size_;
  ::minidfs::ChunkserverInfo* chunkserverinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class BlockTask :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.BlockTask) */ {
 public:
  BlockTask();
  virtual ~BlockTask();

  BlockTask(const BlockTask& from);
  BlockTask(BlockTask&& from) noexcept
    : BlockTask() {
    *this = ::std::move(from);
  }

  inline BlockTask& operator=(const BlockTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockTask& operator=(BlockTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockTask* internal_default_instance() {
    return reinterpret_cast<const BlockTask*>(
               &_BlockTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockTask& a, BlockTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockTask* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockTask* New() const final {
    return CreateMaybeMessage<BlockTask>(nullptr);
  }

  BlockTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockTask& from);
  void MergeFrom(const BlockTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.BlockTask";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocatedBlkFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // .minidfs.LocatedBlock locatedBlk = 2;
  bool has_locatedblk() const;
  void clear_locatedblk();
  const ::minidfs::LocatedBlock& locatedblk() const;
  ::minidfs::LocatedBlock* release_locatedblk();
  ::minidfs::LocatedBlock* mutable_locatedblk();
  void set_allocated_locatedblk(::minidfs::LocatedBlock* locatedblk);

  // int32 operation = 1;
  void clear_operation();
  ::PROTOBUF_NAMESPACE_ID::int32 operation() const;
  void set_operation(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.BlockTask)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::minidfs::LocatedBlock* locatedblk_;
  ::PROTOBUF_NAMESPACE_ID::int32 operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class BlockTasks :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.BlockTasks) */ {
 public:
  BlockTasks();
  virtual ~BlockTasks();

  BlockTasks(const BlockTasks& from);
  BlockTasks(BlockTasks&& from) noexcept
    : BlockTasks() {
    *this = ::std::move(from);
  }

  inline BlockTasks& operator=(const BlockTasks& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockTasks& operator=(BlockTasks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockTasks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockTasks* internal_default_instance() {
    return reinterpret_cast<const BlockTasks*>(
               &_BlockTasks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BlockTasks& a, BlockTasks& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockTasks* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockTasks* New() const final {
    return CreateMaybeMessage<BlockTasks>(nullptr);
  }

  BlockTasks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockTasks>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockTasks& from);
  void MergeFrom(const BlockTasks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockTasks* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.BlockTasks";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlkTasksFieldNumber = 1,
  };
  // repeated .minidfs.BlockTask blkTasks = 1;
  int blktasks_size() const;
  void clear_blktasks();
  ::minidfs::BlockTask* mutable_blktasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::BlockTask >*
      mutable_blktasks();
  const ::minidfs::BlockTask& blktasks(int index) const;
  ::minidfs::BlockTask* add_blktasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::BlockTask >&
      blktasks() const;

  // @@protoc_insertion_point(class_scope:minidfs.BlockTasks)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::BlockTask > blktasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class Inode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.Inode) */ {
 public:
  Inode();
  virtual ~Inode();

  Inode(const Inode& from);
  Inode(Inode&& from) noexcept
    : Inode() {
    *this = ::std::move(from);
  }

  inline Inode& operator=(const Inode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inode& operator=(Inode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Inode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inode* internal_default_instance() {
    return reinterpret_cast<const Inode*>(
               &_Inode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Inode& a, Inode& b) {
    a.Swap(&b);
  }
  inline void Swap(Inode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inode* New() const final {
    return CreateMaybeMessage<Inode>(nullptr);
  }

  Inode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Inode& from);
  void MergeFrom(const Inode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.Inode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlksFieldNumber = 4,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kIsDirFieldNumber = 3,
  };
  // repeated .minidfs.Block blks = 4;
  int blks_size() const;
  void clear_blks();
  ::minidfs::Block* mutable_blks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >*
      mutable_blks();
  const ::minidfs::Block& blks(int index) const;
  ::minidfs::Block* add_blks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >&
      blks() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool isDir = 3;
  void clear_isdir();
  bool isdir() const;
  void set_isdir(bool value);

  // @@protoc_insertion_point(class_scope:minidfs.Inode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block > blks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool isdir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class InodeSection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.InodeSection) */ {
 public:
  InodeSection();
  virtual ~InodeSection();

  InodeSection(const InodeSection& from);
  InodeSection(InodeSection&& from) noexcept
    : InodeSection() {
    *this = ::std::move(from);
  }

  inline InodeSection& operator=(const InodeSection& from) {
    CopyFrom(from);
    return *this;
  }
  inline InodeSection& operator=(InodeSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InodeSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InodeSection* internal_default_instance() {
    return reinterpret_cast<const InodeSection*>(
               &_InodeSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InodeSection& a, InodeSection& b) {
    a.Swap(&b);
  }
  inline void Swap(InodeSection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InodeSection* New() const final {
    return CreateMaybeMessage<InodeSection>(nullptr);
  }

  InodeSection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InodeSection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InodeSection& from);
  void MergeFrom(const InodeSection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InodeSection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.InodeSection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInodesFieldNumber = 1,
  };
  // repeated .minidfs.Inode inodes = 1;
  int inodes_size() const;
  void clear_inodes();
  ::minidfs::Inode* mutable_inodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Inode >*
      mutable_inodes();
  const ::minidfs::Inode& inodes(int index) const;
  ::minidfs::Inode* add_inodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Inode >&
      inodes() const;

  // @@protoc_insertion_point(class_scope:minidfs.InodeSection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Inode > inodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class Dentry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.Dentry) */ {
 public:
  Dentry();
  virtual ~Dentry();

  Dentry(const Dentry& from);
  Dentry(Dentry&& from) noexcept
    : Dentry() {
    *this = ::std::move(from);
  }

  inline Dentry& operator=(const Dentry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dentry& operator=(Dentry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Dentry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dentry* internal_default_instance() {
    return reinterpret_cast<const Dentry*>(
               &_Dentry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Dentry& a, Dentry& b) {
    a.Swap(&b);
  }
  inline void Swap(Dentry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Dentry* New() const final {
    return CreateMaybeMessage<Dentry>(nullptr);
  }

  Dentry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Dentry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Dentry& from);
  void MergeFrom(const Dentry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dentry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.Dentry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubDentriesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated int32 subDentries = 2;
  int subdentries_size() const;
  void clear_subdentries();
  ::PROTOBUF_NAMESPACE_ID::int32 subdentries(int index) const;
  void set_subdentries(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_subdentries(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      subdentries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_subdentries();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.Dentry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > subdentries_;
  mutable std::atomic<int> _subdentries_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class DentrySection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.DentrySection) */ {
 public:
  DentrySection();
  virtual ~DentrySection();

  DentrySection(const DentrySection& from);
  DentrySection(DentrySection&& from) noexcept
    : DentrySection() {
    *this = ::std::move(from);
  }

  inline DentrySection& operator=(const DentrySection& from) {
    CopyFrom(from);
    return *this;
  }
  inline DentrySection& operator=(DentrySection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DentrySection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DentrySection* internal_default_instance() {
    return reinterpret_cast<const DentrySection*>(
               &_DentrySection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DentrySection& a, DentrySection& b) {
    a.Swap(&b);
  }
  inline void Swap(DentrySection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DentrySection* New() const final {
    return CreateMaybeMessage<DentrySection>(nullptr);
  }

  DentrySection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DentrySection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DentrySection& from);
  void MergeFrom(const DentrySection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DentrySection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.DentrySection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDentriesFieldNumber = 1,
  };
  // repeated .minidfs.Dentry dentries = 1;
  int dentries_size() const;
  void clear_dentries();
  ::minidfs::Dentry* mutable_dentries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Dentry >*
      mutable_dentries();
  const ::minidfs::Dentry& dentries(int index) const;
  ::minidfs::Dentry* add_dentries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Dentry >&
      dentries() const;

  // @@protoc_insertion_point(class_scope:minidfs.DentrySection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Dentry > dentries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class NameSystem :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.NameSystem) */ {
 public:
  NameSystem();
  virtual ~NameSystem();

  NameSystem(const NameSystem& from);
  NameSystem(NameSystem&& from) noexcept
    : NameSystem() {
    *this = ::std::move(from);
  }

  inline NameSystem& operator=(const NameSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameSystem& operator=(NameSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameSystem* internal_default_instance() {
    return reinterpret_cast<const NameSystem*>(
               &_NameSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NameSystem& a, NameSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NameSystem* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameSystem* New() const final {
    return CreateMaybeMessage<NameSystem>(nullptr);
  }

  NameSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameSystem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameSystem& from);
  void MergeFrom(const NameSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameSystem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.NameSystem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInodeSectionFieldNumber = 3,
    kDentrySectionFieldNumber = 4,
    kMaxDfIDFieldNumber = 1,
    kMaxBlkIDFieldNumber = 2,
  };
  // .minidfs.InodeSection inodeSection = 3;
  bool has_inodesection() const;
  void clear_inodesection();
  const ::minidfs::InodeSection& inodesection() const;
  ::minidfs::InodeSection* release_inodesection();
  ::minidfs::InodeSection* mutable_inodesection();
  void set_allocated_inodesection(::minidfs::InodeSection* inodesection);

  // .minidfs.DentrySection dentrySection = 4;
  bool has_dentrysection() const;
  void clear_dentrysection();
  const ::minidfs::DentrySection& dentrysection() const;
  ::minidfs::DentrySection* release_dentrysection();
  ::minidfs::DentrySection* mutable_dentrysection();
  void set_allocated_dentrysection(::minidfs::DentrySection* dentrysection);

  // int32 maxDfID = 1;
  void clear_maxdfid();
  ::PROTOBUF_NAMESPACE_ID::int32 maxdfid() const;
  void set_maxdfid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 maxBlkID = 2;
  void clear_maxblkid();
  ::PROTOBUF_NAMESPACE_ID::int32 maxblkid() const;
  void set_maxblkid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.NameSystem)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::minidfs::InodeSection* inodesection_;
  ::minidfs::DentrySection* dentrysection_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxdfid_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxblkid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class EditLog :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.EditLog) */ {
 public:
  EditLog();
  virtual ~EditLog();

  EditLog(const EditLog& from);
  EditLog(EditLog&& from) noexcept
    : EditLog() {
    *this = ::std::move(from);
  }

  inline EditLog& operator=(const EditLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditLog& operator=(EditLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditLog* internal_default_instance() {
    return reinterpret_cast<const EditLog*>(
               &_EditLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EditLog& a, EditLog& b) {
    a.Swap(&b);
  }
  inline void Swap(EditLog* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditLog* New() const final {
    return CreateMaybeMessage<EditLog>(nullptr);
  }

  EditLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditLog>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditLog& from);
  void MergeFrom(const EditLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.EditLog";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlksFieldNumber = 6,
    kSrcFieldNumber = 2,
    kOpFieldNumber = 1,
    kDfIDFieldNumber = 3,
  };
  // repeated .minidfs.Block blks = 6;
  int blks_size() const;
  void clear_blks();
  ::minidfs::Block* mutable_blks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >*
      mutable_blks();
  const ::minidfs::Block& blks(int index) const;
  ::minidfs::Block* add_blks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >&
      blks() const;

  // string src = 2;
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);

  // int32 op = 1;
  void clear_op();
  ::PROTOBUF_NAMESPACE_ID::int32 op() const;
  void set_op(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 dfID = 3;
  void clear_dfid();
  ::PROTOBUF_NAMESPACE_ID::int32 dfid() const;
  void set_dfid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:minidfs.EditLog)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block > blks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::int32 op_;
  ::PROTOBUF_NAMESPACE_ID::int32 dfid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class FileInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return CreateMaybeMessage<FileInfo>(nullptr);
  }

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.FileInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFileLenFieldNumber = 3,
    kIsDirFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int64 fileLen = 3;
  void clear_filelen();
  ::PROTOBUF_NAMESPACE_ID::int64 filelen() const;
  void set_filelen(::PROTOBUF_NAMESPACE_ID::int64 value);

  // bool isDir = 2;
  void clear_isdir();
  bool isdir() const;
  void set_isdir(bool value);

  // @@protoc_insertion_point(class_scope:minidfs.FileInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 filelen_;
  bool isdir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// -------------------------------------------------------------------

class FileInfos :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minidfs.FileInfos) */ {
 public:
  FileInfos();
  virtual ~FileInfos();

  FileInfos(const FileInfos& from);
  FileInfos(FileInfos&& from) noexcept
    : FileInfos() {
    *this = ::std::move(from);
  }

  inline FileInfos& operator=(const FileInfos& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfos& operator=(FileInfos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileInfos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfos* internal_default_instance() {
    return reinterpret_cast<const FileInfos*>(
               &_FileInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FileInfos& a, FileInfos& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfos* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileInfos* New() const final {
    return CreateMaybeMessage<FileInfos>(nullptr);
  }

  FileInfos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileInfos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileInfos& from);
  void MergeFrom(const FileInfos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minidfs.FileInfos";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_minidfs_2eproto);
    return ::descriptor_table_minidfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileInfosFieldNumber = 1,
  };
  // repeated .minidfs.FileInfo fileInfos = 1;
  int fileinfos_size() const;
  void clear_fileinfos();
  ::minidfs::FileInfo* mutable_fileinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::FileInfo >*
      mutable_fileinfos();
  const ::minidfs::FileInfo& fileinfos(int index) const;
  ::minidfs::FileInfo* add_fileinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::FileInfo >&
      fileinfos() const;

  // @@protoc_insertion_point(class_scope:minidfs.FileInfos)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::FileInfo > fileinfos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minidfs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Block

// int32 blockID = 1;
inline void Block::clear_blockid() {
  blockid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Block::blockid() const {
  // @@protoc_insertion_point(field_get:minidfs.Block.blockID)
  return blockid_;
}
inline void Block::set_blockid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  blockid_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Block.blockID)
}

// int64 blockLen = 2;
inline void Block::clear_blocklen() {
  blocklen_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Block::blocklen() const {
  // @@protoc_insertion_point(field_get:minidfs.Block.blockLen)
  return blocklen_;
}
inline void Block::set_blocklen(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  blocklen_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Block.blockLen)
}

// -------------------------------------------------------------------

// ChunkserverInfo

// string chunkserverIP = 1;
inline void ChunkserverInfo::clear_chunkserverip() {
  chunkserverip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChunkserverInfo::chunkserverip() const {
  // @@protoc_insertion_point(field_get:minidfs.ChunkserverInfo.chunkserverIP)
  return chunkserverip_.GetNoArena();
}
inline void ChunkserverInfo::set_chunkserverip(const std::string& value) {
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(std::string&& value) {
  
  chunkserverip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.ChunkserverInfo.chunkserverIP)
}
inline void ChunkserverInfo::set_chunkserverip(const char* value, size_t size) {
  
  chunkserverip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.ChunkserverInfo.chunkserverIP)
}
inline std::string* ChunkserverInfo::mutable_chunkserverip() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.ChunkserverInfo.chunkserverIP)
  return chunkserverip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChunkserverInfo::release_chunkserverip() {
  // @@protoc_insertion_point(field_release:minidfs.ChunkserverInfo.chunkserverIP)
  
  return chunkserverip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChunkserverInfo::set_allocated_chunkserverip(std::string* chunkserverip) {
  if (chunkserverip != nullptr) {
    
  } else {
    
  }
  chunkserverip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunkserverip);
  // @@protoc_insertion_point(field_set_allocated:minidfs.ChunkserverInfo.chunkserverIP)
}

// int32 chunkserverPort = 2;
inline void ChunkserverInfo::clear_chunkserverport() {
  chunkserverport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkserverInfo::chunkserverport() const {
  // @@protoc_insertion_point(field_get:minidfs.ChunkserverInfo.chunkserverPort)
  return chunkserverport_;
}
inline void ChunkserverInfo::set_chunkserverport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chunkserverport_ = value;
  // @@protoc_insertion_point(field_set:minidfs.ChunkserverInfo.chunkserverPort)
}

// -------------------------------------------------------------------

// LocatedBlock

// .minidfs.Block block = 1;
inline bool LocatedBlock::has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline void LocatedBlock::clear_block() {
  if (GetArenaNoVirtual() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::minidfs::Block& LocatedBlock::block() const {
  const ::minidfs::Block* p = block_;
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlock.block)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::Block*>(
      &::minidfs::_Block_default_instance_);
}
inline ::minidfs::Block* LocatedBlock::release_block() {
  // @@protoc_insertion_point(field_release:minidfs.LocatedBlock.block)
  
  ::minidfs::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::minidfs::Block* LocatedBlock::mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlock.block)
  return block_;
}
inline void LocatedBlock::set_allocated_block(::minidfs::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:minidfs.LocatedBlock.block)
}

// repeated .minidfs.ChunkserverInfo chunkserverInfos = 2;
inline int LocatedBlock::chunkserverinfos_size() const {
  return chunkserverinfos_.size();
}
inline void LocatedBlock::clear_chunkserverinfos() {
  chunkserverinfos_.Clear();
}
inline ::minidfs::ChunkserverInfo* LocatedBlock::mutable_chunkserverinfos(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >*
LocatedBlock::mutable_chunkserverinfos() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.LocatedBlock.chunkserverInfos)
  return &chunkserverinfos_;
}
inline const ::minidfs::ChunkserverInfo& LocatedBlock::chunkserverinfos(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Get(index);
}
inline ::minidfs::ChunkserverInfo* LocatedBlock::add_chunkserverinfos() {
  // @@protoc_insertion_point(field_add:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::ChunkserverInfo >&
LocatedBlock::chunkserverinfos() const {
  // @@protoc_insertion_point(field_list:minidfs.LocatedBlock.chunkserverInfos)
  return chunkserverinfos_;
}

// -------------------------------------------------------------------

// LocatedBlocks

// repeated .minidfs.LocatedBlock locatedBlks = 1;
inline int LocatedBlocks::locatedblks_size() const {
  return locatedblks_.size();
}
inline void LocatedBlocks::clear_locatedblks() {
  locatedblks_.Clear();
}
inline ::minidfs::LocatedBlock* LocatedBlocks::mutable_locatedblks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >*
LocatedBlocks::mutable_locatedblks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.LocatedBlocks.locatedBlks)
  return &locatedblks_;
}
inline const ::minidfs::LocatedBlock& LocatedBlocks::locatedblks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Get(index);
}
inline ::minidfs::LocatedBlock* LocatedBlocks::add_locatedblks() {
  // @@protoc_insertion_point(field_add:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::LocatedBlock >&
LocatedBlocks::locatedblks() const {
  // @@protoc_insertion_point(field_list:minidfs.LocatedBlocks.locatedBlks)
  return locatedblks_;
}

// -------------------------------------------------------------------

// BlkIDs

// repeated int32 blkIDs = 1;
inline int BlkIDs::blkids_size() const {
  return blkids_.size();
}
inline void BlkIDs::clear_blkids() {
  blkids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlkIDs::blkids(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.BlkIDs.blkIDs)
  return blkids_.Get(index);
}
inline void BlkIDs::set_blkids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  blkids_.Set(index, value);
  // @@protoc_insertion_point(field_set:minidfs.BlkIDs.blkIDs)
}
inline void BlkIDs::add_blkids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  blkids_.Add(value);
  // @@protoc_insertion_point(field_add:minidfs.BlkIDs.blkIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
BlkIDs::blkids() const {
  // @@protoc_insertion_point(field_list:minidfs.BlkIDs.blkIDs)
  return blkids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
BlkIDs::mutable_blkids() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.BlkIDs.blkIDs)
  return &blkids_;
}

// -------------------------------------------------------------------

// BlockReport

// .minidfs.ChunkserverInfo chunkserverInfo = 1;
inline bool BlockReport::has_chunkserverinfo() const {
  return this != internal_default_instance() && chunkserverinfo_ != nullptr;
}
inline void BlockReport::clear_chunkserverinfo() {
  if (GetArenaNoVirtual() == nullptr && chunkserverinfo_ != nullptr) {
    delete chunkserverinfo_;
  }
  chunkserverinfo_ = nullptr;
}
inline const ::minidfs::ChunkserverInfo& BlockReport::chunkserverinfo() const {
  const ::minidfs::ChunkserverInfo* p = chunkserverinfo_;
  // @@protoc_insertion_point(field_get:minidfs.BlockReport.chunkserverInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::ChunkserverInfo*>(
      &::minidfs::_ChunkserverInfo_default_instance_);
}
inline ::minidfs::ChunkserverInfo* BlockReport::release_chunkserverinfo() {
  // @@protoc_insertion_point(field_release:minidfs.BlockReport.chunkserverInfo)
  
  ::minidfs::ChunkserverInfo* temp = chunkserverinfo_;
  chunkserverinfo_ = nullptr;
  return temp;
}
inline ::minidfs::ChunkserverInfo* BlockReport::mutable_chunkserverinfo() {
  
  if (chunkserverinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::ChunkserverInfo>(GetArenaNoVirtual());
    chunkserverinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.BlockReport.chunkserverInfo)
  return chunkserverinfo_;
}
inline void BlockReport::set_allocated_chunkserverinfo(::minidfs::ChunkserverInfo* chunkserverinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chunkserverinfo_;
  }
  if (chunkserverinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chunkserverinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunkserverinfo, submessage_arena);
    }
    
  } else {
    
  }
  chunkserverinfo_ = chunkserverinfo;
  // @@protoc_insertion_point(field_set_allocated:minidfs.BlockReport.chunkserverInfo)
}

// repeated int32 blkIDs = 2;
inline int BlockReport::blkids_size() const {
  return blkids_.size();
}
inline void BlockReport::clear_blkids() {
  blkids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockReport::blkids(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.BlockReport.blkIDs)
  return blkids_.Get(index);
}
inline void BlockReport::set_blkids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  blkids_.Set(index, value);
  // @@protoc_insertion_point(field_set:minidfs.BlockReport.blkIDs)
}
inline void BlockReport::add_blkids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  blkids_.Add(value);
  // @@protoc_insertion_point(field_add:minidfs.BlockReport.blkIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
BlockReport::blkids() const {
  // @@protoc_insertion_point(field_list:minidfs.BlockReport.blkIDs)
  return blkids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
BlockReport::mutable_blkids() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.BlockReport.blkIDs)
  return &blkids_;
}

// -------------------------------------------------------------------

// BlockTask

// int32 operation = 1;
inline void BlockTask::clear_operation() {
  operation_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockTask::operation() const {
  // @@protoc_insertion_point(field_get:minidfs.BlockTask.operation)
  return operation_;
}
inline void BlockTask::set_operation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  operation_ = value;
  // @@protoc_insertion_point(field_set:minidfs.BlockTask.operation)
}

// .minidfs.LocatedBlock locatedBlk = 2;
inline bool BlockTask::has_locatedblk() const {
  return this != internal_default_instance() && locatedblk_ != nullptr;
}
inline void BlockTask::clear_locatedblk() {
  if (GetArenaNoVirtual() == nullptr && locatedblk_ != nullptr) {
    delete locatedblk_;
  }
  locatedblk_ = nullptr;
}
inline const ::minidfs::LocatedBlock& BlockTask::locatedblk() const {
  const ::minidfs::LocatedBlock* p = locatedblk_;
  // @@protoc_insertion_point(field_get:minidfs.BlockTask.locatedBlk)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::LocatedBlock*>(
      &::minidfs::_LocatedBlock_default_instance_);
}
inline ::minidfs::LocatedBlock* BlockTask::release_locatedblk() {
  // @@protoc_insertion_point(field_release:minidfs.BlockTask.locatedBlk)
  
  ::minidfs::LocatedBlock* temp = locatedblk_;
  locatedblk_ = nullptr;
  return temp;
}
inline ::minidfs::LocatedBlock* BlockTask::mutable_locatedblk() {
  
  if (locatedblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::LocatedBlock>(GetArenaNoVirtual());
    locatedblk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.BlockTask.locatedBlk)
  return locatedblk_;
}
inline void BlockTask::set_allocated_locatedblk(::minidfs::LocatedBlock* locatedblk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete locatedblk_;
  }
  if (locatedblk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      locatedblk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locatedblk, submessage_arena);
    }
    
  } else {
    
  }
  locatedblk_ = locatedblk;
  // @@protoc_insertion_point(field_set_allocated:minidfs.BlockTask.locatedBlk)
}

// -------------------------------------------------------------------

// BlockTasks

// repeated .minidfs.BlockTask blkTasks = 1;
inline int BlockTasks::blktasks_size() const {
  return blktasks_.size();
}
inline void BlockTasks::clear_blktasks() {
  blktasks_.Clear();
}
inline ::minidfs::BlockTask* BlockTasks::mutable_blktasks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.BlockTasks.blkTasks)
  return blktasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::BlockTask >*
BlockTasks::mutable_blktasks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.BlockTasks.blkTasks)
  return &blktasks_;
}
inline const ::minidfs::BlockTask& BlockTasks::blktasks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.BlockTasks.blkTasks)
  return blktasks_.Get(index);
}
inline ::minidfs::BlockTask* BlockTasks::add_blktasks() {
  // @@protoc_insertion_point(field_add:minidfs.BlockTasks.blkTasks)
  return blktasks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::BlockTask >&
BlockTasks::blktasks() const {
  // @@protoc_insertion_point(field_list:minidfs.BlockTasks.blkTasks)
  return blktasks_;
}

// -------------------------------------------------------------------

// Inode

// int32 id = 1;
inline void Inode::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Inode::id() const {
  // @@protoc_insertion_point(field_get:minidfs.Inode.id)
  return id_;
}
inline void Inode::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Inode.id)
}

// string name = 2;
inline void Inode::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Inode::name() const {
  // @@protoc_insertion_point(field_get:minidfs.Inode.name)
  return name_.GetNoArena();
}
inline void Inode::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.Inode.name)
}
inline void Inode::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.Inode.name)
}
inline void Inode::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.Inode.name)
}
inline void Inode::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.Inode.name)
}
inline std::string* Inode::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.Inode.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Inode::release_name() {
  // @@protoc_insertion_point(field_release:minidfs.Inode.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Inode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:minidfs.Inode.name)
}

// bool isDir = 3;
inline void Inode::clear_isdir() {
  isdir_ = false;
}
inline bool Inode::isdir() const {
  // @@protoc_insertion_point(field_get:minidfs.Inode.isDir)
  return isdir_;
}
inline void Inode::set_isdir(bool value) {
  
  isdir_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Inode.isDir)
}

// repeated .minidfs.Block blks = 4;
inline int Inode::blks_size() const {
  return blks_.size();
}
inline void Inode::clear_blks() {
  blks_.Clear();
}
inline ::minidfs::Block* Inode::mutable_blks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.Inode.blks)
  return blks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >*
Inode::mutable_blks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.Inode.blks)
  return &blks_;
}
inline const ::minidfs::Block& Inode::blks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.Inode.blks)
  return blks_.Get(index);
}
inline ::minidfs::Block* Inode::add_blks() {
  // @@protoc_insertion_point(field_add:minidfs.Inode.blks)
  return blks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >&
Inode::blks() const {
  // @@protoc_insertion_point(field_list:minidfs.Inode.blks)
  return blks_;
}

// -------------------------------------------------------------------

// InodeSection

// repeated .minidfs.Inode inodes = 1;
inline int InodeSection::inodes_size() const {
  return inodes_.size();
}
inline void InodeSection::clear_inodes() {
  inodes_.Clear();
}
inline ::minidfs::Inode* InodeSection::mutable_inodes(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.InodeSection.inodes)
  return inodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Inode >*
InodeSection::mutable_inodes() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.InodeSection.inodes)
  return &inodes_;
}
inline const ::minidfs::Inode& InodeSection::inodes(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.InodeSection.inodes)
  return inodes_.Get(index);
}
inline ::minidfs::Inode* InodeSection::add_inodes() {
  // @@protoc_insertion_point(field_add:minidfs.InodeSection.inodes)
  return inodes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Inode >&
InodeSection::inodes() const {
  // @@protoc_insertion_point(field_list:minidfs.InodeSection.inodes)
  return inodes_;
}

// -------------------------------------------------------------------

// Dentry

// int32 id = 1;
inline void Dentry::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dentry::id() const {
  // @@protoc_insertion_point(field_get:minidfs.Dentry.id)
  return id_;
}
inline void Dentry::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:minidfs.Dentry.id)
}

// repeated int32 subDentries = 2;
inline int Dentry::subdentries_size() const {
  return subdentries_.size();
}
inline void Dentry::clear_subdentries() {
  subdentries_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dentry::subdentries(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.Dentry.subDentries)
  return subdentries_.Get(index);
}
inline void Dentry::set_subdentries(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  subdentries_.Set(index, value);
  // @@protoc_insertion_point(field_set:minidfs.Dentry.subDentries)
}
inline void Dentry::add_subdentries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  subdentries_.Add(value);
  // @@protoc_insertion_point(field_add:minidfs.Dentry.subDentries)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Dentry::subdentries() const {
  // @@protoc_insertion_point(field_list:minidfs.Dentry.subDentries)
  return subdentries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Dentry::mutable_subdentries() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.Dentry.subDentries)
  return &subdentries_;
}

// -------------------------------------------------------------------

// DentrySection

// repeated .minidfs.Dentry dentries = 1;
inline int DentrySection::dentries_size() const {
  return dentries_.size();
}
inline void DentrySection::clear_dentries() {
  dentries_.Clear();
}
inline ::minidfs::Dentry* DentrySection::mutable_dentries(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.DentrySection.dentries)
  return dentries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Dentry >*
DentrySection::mutable_dentries() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.DentrySection.dentries)
  return &dentries_;
}
inline const ::minidfs::Dentry& DentrySection::dentries(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.DentrySection.dentries)
  return dentries_.Get(index);
}
inline ::minidfs::Dentry* DentrySection::add_dentries() {
  // @@protoc_insertion_point(field_add:minidfs.DentrySection.dentries)
  return dentries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Dentry >&
DentrySection::dentries() const {
  // @@protoc_insertion_point(field_list:minidfs.DentrySection.dentries)
  return dentries_;
}

// -------------------------------------------------------------------

// NameSystem

// int32 maxDfID = 1;
inline void NameSystem::clear_maxdfid() {
  maxdfid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NameSystem::maxdfid() const {
  // @@protoc_insertion_point(field_get:minidfs.NameSystem.maxDfID)
  return maxdfid_;
}
inline void NameSystem::set_maxdfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxdfid_ = value;
  // @@protoc_insertion_point(field_set:minidfs.NameSystem.maxDfID)
}

// int32 maxBlkID = 2;
inline void NameSystem::clear_maxblkid() {
  maxblkid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NameSystem::maxblkid() const {
  // @@protoc_insertion_point(field_get:minidfs.NameSystem.maxBlkID)
  return maxblkid_;
}
inline void NameSystem::set_maxblkid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxblkid_ = value;
  // @@protoc_insertion_point(field_set:minidfs.NameSystem.maxBlkID)
}

// .minidfs.InodeSection inodeSection = 3;
inline bool NameSystem::has_inodesection() const {
  return this != internal_default_instance() && inodesection_ != nullptr;
}
inline void NameSystem::clear_inodesection() {
  if (GetArenaNoVirtual() == nullptr && inodesection_ != nullptr) {
    delete inodesection_;
  }
  inodesection_ = nullptr;
}
inline const ::minidfs::InodeSection& NameSystem::inodesection() const {
  const ::minidfs::InodeSection* p = inodesection_;
  // @@protoc_insertion_point(field_get:minidfs.NameSystem.inodeSection)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::InodeSection*>(
      &::minidfs::_InodeSection_default_instance_);
}
inline ::minidfs::InodeSection* NameSystem::release_inodesection() {
  // @@protoc_insertion_point(field_release:minidfs.NameSystem.inodeSection)
  
  ::minidfs::InodeSection* temp = inodesection_;
  inodesection_ = nullptr;
  return temp;
}
inline ::minidfs::InodeSection* NameSystem::mutable_inodesection() {
  
  if (inodesection_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::InodeSection>(GetArenaNoVirtual());
    inodesection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.NameSystem.inodeSection)
  return inodesection_;
}
inline void NameSystem::set_allocated_inodesection(::minidfs::InodeSection* inodesection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inodesection_;
  }
  if (inodesection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inodesection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inodesection, submessage_arena);
    }
    
  } else {
    
  }
  inodesection_ = inodesection;
  // @@protoc_insertion_point(field_set_allocated:minidfs.NameSystem.inodeSection)
}

// .minidfs.DentrySection dentrySection = 4;
inline bool NameSystem::has_dentrysection() const {
  return this != internal_default_instance() && dentrysection_ != nullptr;
}
inline void NameSystem::clear_dentrysection() {
  if (GetArenaNoVirtual() == nullptr && dentrysection_ != nullptr) {
    delete dentrysection_;
  }
  dentrysection_ = nullptr;
}
inline const ::minidfs::DentrySection& NameSystem::dentrysection() const {
  const ::minidfs::DentrySection* p = dentrysection_;
  // @@protoc_insertion_point(field_get:minidfs.NameSystem.dentrySection)
  return p != nullptr ? *p : *reinterpret_cast<const ::minidfs::DentrySection*>(
      &::minidfs::_DentrySection_default_instance_);
}
inline ::minidfs::DentrySection* NameSystem::release_dentrysection() {
  // @@protoc_insertion_point(field_release:minidfs.NameSystem.dentrySection)
  
  ::minidfs::DentrySection* temp = dentrysection_;
  dentrysection_ = nullptr;
  return temp;
}
inline ::minidfs::DentrySection* NameSystem::mutable_dentrysection() {
  
  if (dentrysection_ == nullptr) {
    auto* p = CreateMaybeMessage<::minidfs::DentrySection>(GetArenaNoVirtual());
    dentrysection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:minidfs.NameSystem.dentrySection)
  return dentrysection_;
}
inline void NameSystem::set_allocated_dentrysection(::minidfs::DentrySection* dentrysection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dentrysection_;
  }
  if (dentrysection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dentrysection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dentrysection, submessage_arena);
    }
    
  } else {
    
  }
  dentrysection_ = dentrysection;
  // @@protoc_insertion_point(field_set_allocated:minidfs.NameSystem.dentrySection)
}

// -------------------------------------------------------------------

// EditLog

// int32 op = 1;
inline void EditLog::clear_op() {
  op_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EditLog::op() const {
  // @@protoc_insertion_point(field_get:minidfs.EditLog.op)
  return op_;
}
inline void EditLog::set_op(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:minidfs.EditLog.op)
}

// string src = 2;
inline void EditLog::clear_src() {
  src_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EditLog::src() const {
  // @@protoc_insertion_point(field_get:minidfs.EditLog.src)
  return src_.GetNoArena();
}
inline void EditLog::set_src(const std::string& value) {
  
  src_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.EditLog.src)
}
inline void EditLog::set_src(std::string&& value) {
  
  src_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.EditLog.src)
}
inline void EditLog::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  src_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.EditLog.src)
}
inline void EditLog::set_src(const char* value, size_t size) {
  
  src_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.EditLog.src)
}
inline std::string* EditLog::mutable_src() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.EditLog.src)
  return src_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EditLog::release_src() {
  // @@protoc_insertion_point(field_release:minidfs.EditLog.src)
  
  return src_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EditLog::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  src_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:minidfs.EditLog.src)
}

// int32 dfID = 3;
inline void EditLog::clear_dfid() {
  dfid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EditLog::dfid() const {
  // @@protoc_insertion_point(field_get:minidfs.EditLog.dfID)
  return dfid_;
}
inline void EditLog::set_dfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dfid_ = value;
  // @@protoc_insertion_point(field_set:minidfs.EditLog.dfID)
}

// repeated .minidfs.Block blks = 6;
inline int EditLog::blks_size() const {
  return blks_.size();
}
inline void EditLog::clear_blks() {
  blks_.Clear();
}
inline ::minidfs::Block* EditLog::mutable_blks(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.EditLog.blks)
  return blks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >*
EditLog::mutable_blks() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.EditLog.blks)
  return &blks_;
}
inline const ::minidfs::Block& EditLog::blks(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.EditLog.blks)
  return blks_.Get(index);
}
inline ::minidfs::Block* EditLog::add_blks() {
  // @@protoc_insertion_point(field_add:minidfs.EditLog.blks)
  return blks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::Block >&
EditLog::blks() const {
  // @@protoc_insertion_point(field_list:minidfs.EditLog.blks)
  return blks_;
}

// -------------------------------------------------------------------

// FileInfo

// string name = 1;
inline void FileInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FileInfo::name() const {
  // @@protoc_insertion_point(field_get:minidfs.FileInfo.name)
  return name_.GetNoArena();
}
inline void FileInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:minidfs.FileInfo.name)
}
inline void FileInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:minidfs.FileInfo.name)
}
inline void FileInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:minidfs.FileInfo.name)
}
inline void FileInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:minidfs.FileInfo.name)
}
inline std::string* FileInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:minidfs.FileInfo.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileInfo::release_name() {
  // @@protoc_insertion_point(field_release:minidfs.FileInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:minidfs.FileInfo.name)
}

// bool isDir = 2;
inline void FileInfo::clear_isdir() {
  isdir_ = false;
}
inline bool FileInfo::isdir() const {
  // @@protoc_insertion_point(field_get:minidfs.FileInfo.isDir)
  return isdir_;
}
inline void FileInfo::set_isdir(bool value) {
  
  isdir_ = value;
  // @@protoc_insertion_point(field_set:minidfs.FileInfo.isDir)
}

// int64 fileLen = 3;
inline void FileInfo::clear_filelen() {
  filelen_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileInfo::filelen() const {
  // @@protoc_insertion_point(field_get:minidfs.FileInfo.fileLen)
  return filelen_;
}
inline void FileInfo::set_filelen(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  filelen_ = value;
  // @@protoc_insertion_point(field_set:minidfs.FileInfo.fileLen)
}

// -------------------------------------------------------------------

// FileInfos

// repeated .minidfs.FileInfo fileInfos = 1;
inline int FileInfos::fileinfos_size() const {
  return fileinfos_.size();
}
inline void FileInfos::clear_fileinfos() {
  fileinfos_.Clear();
}
inline ::minidfs::FileInfo* FileInfos::mutable_fileinfos(int index) {
  // @@protoc_insertion_point(field_mutable:minidfs.FileInfos.fileInfos)
  return fileinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::FileInfo >*
FileInfos::mutable_fileinfos() {
  // @@protoc_insertion_point(field_mutable_list:minidfs.FileInfos.fileInfos)
  return &fileinfos_;
}
inline const ::minidfs::FileInfo& FileInfos::fileinfos(int index) const {
  // @@protoc_insertion_point(field_get:minidfs.FileInfos.fileInfos)
  return fileinfos_.Get(index);
}
inline ::minidfs::FileInfo* FileInfos::add_fileinfos() {
  // @@protoc_insertion_point(field_add:minidfs.FileInfos.fileInfos)
  return fileinfos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minidfs::FileInfo >&
FileInfos::fileinfos() const {
  // @@protoc_insertion_point(field_list:minidfs.FileInfos.fileInfos)
  return fileinfos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace minidfs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minidfs_2eproto
